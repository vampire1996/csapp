#异常控制流

EFC是操作系统西还能I/O,进程和虚拟内存的基本机制。
EFC也是操作系统实现并发的基本机制--中断应用程序处执行的异常处理程序，在时间上重叠执行的进程和线程，中断应用程序执行的信号处理程序。

C++和Java通过try,catch以及throw语句提供软件异常机制。--非本地跳转是一种应用层EFC

控制流--控制转移序列--一系列指令的地址

异常处理--系统对系统状态的变化进行反应--子进程终止，创造子进程的父进程必须得到通知。--控制流突变对这些情况做出反应


## 异常
异常是控制流中的突变，来响应处理器中的某些变化。

状态变化--事件

当处理器检测到有事件发生时，它会通过一张异常检测表的跳转表，进行一个间接过程调用，到异常处理程序(exception handler)

### 异常处理

系统中可能的每个类型的异常都分配了唯一一个非负整数异常号

异常可以分为四类--通常异常值得是同步异常

(1)中断--来自I/O设备的信号(网络适配器，磁盘控制器，定时器芯片)，相对于处理器异步发生 除了中断，其它异常都是同步发生的。

(2)陷阱--故意的异常--为用户程序和内核之间提供一个像过程调用一样的接口--系统调用
用户程序向内核请求服务--read,fork,execve(加载一个新程序),exit(终止当前进程)--是syscall n
系统调用和普通函数的区别是，他们的实现不同:普通函数运行在用户模式，系统调用在内核模式--允许系统调用待执行特权指令，并访问定义在内核中的栈

(3)故障--由错误情况引起

如果能被故障处理程序修正，那么重新执行当前的指令，否则返回内核中的abort例程，终止引起故障的应用程序。

(3)终止--不可回复的致命错误导致的结果--返回abort，终止应用程序

### Linux/x86-64故障和终止

除法错误--floating exception--浮点异常
一般保护故障--通常是应为程序应用了未定义的虚拟内存区域--段故障
缺页

### Linux/x86-64系统调用

C中syscall函数可以调用任何系统调用，实际上C库提供了一系列包装函数--以适当的系统调用指令陷入内核--然后将系统调用的返回状态返回给调用程序--系统级函数

LInux系统调用的参数都是通过寄存器而不是栈传递的

write(1,"hello,world\n",13) \\将hello，world写到stdout中

## 进程

进程--一个执行中程序的实例；系统中每个程序都运行在某个进程的上下文中(context)，上下文是由程序正确运行所需的状态所组成的--包括存放在内存中的程序的代码和数据，它的栈，通用寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。

每次用户向shell输入一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个进程的上下文中运行这个可执行文件。应用程序也能创建新进程，并且在这个新进程中的上下文中运行它们自己的代码或其它应用程序。

进程提供给应用程序的关键抽象:
(1)一个独立的逻辑控制流，提供一种当前程序独占处理器的假象
(2)一个私有的地址空间，提供一种当前程序独占内存系统的假象

### 逻辑控制流

PC程序计数器--唯一对应于包含在程序的可执行目标文件中的指令，或者包含在运行时动态链接到程序的共享程序的指令--PC值的序列叫做逻辑控制流

每个进程轮流使用处理器，每个进程是执行它的流的一部分，然后被抢占(preempted)(暂时挂起)--然后轮到其它进程。


### 并发流

一个逻辑流的执行在时间上和另一个重叠，叫做并发流(concurrent flow)。--和核的数目以及计算机的数目无关

多个流并发的执行叫做并发。一个精诚和其他精诚轮流运行的概念叫做多任务(multitasking)。

每个精诚执行它的控制流的一部分的每个时间段叫做时间片(time slice)--多任务也叫时间分片

如果；两个流并发额运行在不同的处理器核或者计算机上，它们为并行流(parallel flow)，它们并行的运行

### 私有地址空间

进程在内存中保存的上下文的内容。
上下文是由程序正确运行所需的状态所组成的--包括存放在内存中的程序的代码和数据，它的栈，通用寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。

### 用户模式和内核模式

某个控制寄存器--模式位--模式位置位--当前进程运行在内核模式--可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。

否则--用户模式--不允许执行特权指令--比如发起一个I/O操作

用户程序必须通过系统调用间接的访问内核代码和数据。--通过中断，故障，陷阱，处理程序运行在内核中

linux中/porc文件系统允许用户精诚访问内核数据结构的内容。

### 上下文切换

操作系统内核使用上下文切换的叫高层的异常控制流来实现多任务--建立在之前提到的叫底层异常机制智商

内核为每个进程维持一个上下文--内核重新启动一个被抢占的进程所需的状态

在系统的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前抢占的进程--这种决策叫做调度(schelduling)。

在内核调度了一个新的进程运行之后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程

上下文切换(1)保存当前进程的上下文。(2)恢复先前被抢占进程的被保存的上下文(3)j将控制传递给这个新恢复的进程

当系统调用代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个时间而发生阻塞，那么内核可以让当前进程休眠。

中断也可能引上下文切换。--比如定时器中断

举例:进程A初始运行在用户模式。知道它通过执行系统调用read陷入内核。内核中的陷阱处理程序请求来自磁盘控制器的DMA传输并且安排在磁盘控制器完成磁盘到内存的数据传输之后，中断磁盘控制器。

磁盘取数据要用较长时间(几十毫秒)--注意这部分不是内存的工作，内核执行进程A到B的上下文切换。这里选择上下文切换的原因是，A进程无需在这么长的时间内等待(比如死循环，然后跳出)，这样比较节省A进程消耗的系统资源。

切换之前，内核正在代表进程A在用户模式下执行命令(注意:没有单独的内核进程)。切换的第一不能分钟，内核代表进程A在内核模式下执行指令，然后在某一时刻，他开始代表进程B执行指令。在切换之后，内核代表进程B在用户模式下执行指令。

## 系统调用错误

当Unix函数遇到错误时，它们通常会返回-1，并设置全局整数变量errno来表示什么出错了。

错误处理包装函数--将系统调用和错误检查封装到一个函数中

## 进程控制

### 获取进程ID

getpid--返回调用进程的PID

petgppid--返回父进程的PID

### 创建和终止进程

程序员角度，进程有三种状态

运行--进程在CPU上执行或者在等待执行且最终会被内核调度。

停止--进程的执行信号被挂起(suspennded)，且不会被调度。当收到SIGSTOP，SIGTSTP,SIGTTIN或者SIGTTOU信号时，进程就停止，直到收到一个SIGCONT，在这个时刻，进程开始再次运行。

终止--进程永远的停止了。(1)收到一个信号，该进程的默认行为是终止进程(2)从主程序返回(3)调用exit函数--以status退出状态来终止进程(另一种退出状态的方法是从主程序中返回一个整数值)

父进程通过调用fork函数创建一个新的运行的子进程。

子进程得到和父进程用户级虚拟内存空间相同(但是独立的)一份副本，包括代码和数据段,堆，共享库以及用户栈。子进程还获得于父进程任何打开文件描述符相同的副本。当父进程调用fork函数，子进程可以读写父进程中打开的任何文件。

父进程和子进程最大的区别是他们有不同的PID



**父进程和子进程**

调用一次，返回两次--调用一次，返回两次fork函数调用一次，返回两次。一次在调用进程(父进程中)，一次在创建的子进程中。父进程中返回子进程的PID，子进程中，fork返回0--用于分辨父进程还是子进程。

并发运行--父进程和子进程是并发运行的独立进程，内核可以以任意方式交替执行它们的逻辑控制流中的指令--不能对不同进程中的指令的交替执行做任何假设。

相同但是独立的地址空间--子进程得到和父进程用户级虚拟内存空间相同(但是独立的)一份副本，包括代码和数据段,堆，共享库以及用户栈。但是子进程和父进程对于内部数据的修改是独立的--独立的进程，各自拥有私有的地址空间。

共享文件--子进程还获得于父进程任何打开文件描述符相同的副本。当父进程调用fork函数，子进程可以读写父进程中打开的任何文件。父进程调用fork时，stdout文件是打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。

进程图--对于运行在处理器上的程序，对应进程图中所有顶点的拓扑排序表示程序中语句的一个可行的全序排列。图谱排序--当且仅当画出的每条边的方向是从左往右的。


### 回收子进程

当一个进程由于某种原因终止时，内核不是立即把它从系统中清除，相反，内核被保持在一种已终止的状态，知道它被父进程收回(reaped).当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个终止但还没有回收的进程叫做僵尸进程。


如果父进程终止了，内核会安排init进程作为它孤儿进程的养父。init进程的PID是1，是在系统启动时由内核创建，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵尸子进程就终止，那么内核会安排init进程取回收他们。不过长时间运行的程序，比如shell或者服务器，总是应该回收它们的僵尸子进程。僵尸进程没有运行也会消耗系统对内存资源。

一个进程可以调用waitpid函数等待它的子进程终止或者停止。成功返回子进程PID，

在默认情况下(options=0)，waitpid挂起调用进程的执行，直到它的等待集合(wait set)中的一个子进程终止，如果等待集合中的一个进程在刚调用的时候就已经终止，那么waitpid就立刻返回。返回导致waitpid终止的已终止子进程的pid。此时，已终止的子进程已经被收回，内核会从系统中删除它的所有浏览痕迹。

错误条件:如果调用进程没有子进程，那么waitpid返回-1，并且设置errno位ECHILD，如果一个waitpid函数被信号中断，那么它返回-1，并设置errno为EINTR

wait函数是waitpid函数的简单版本

注意:程序不会按照特定的顺序回收子进程，子进程的回收顺序是这台计算机的特有属性。--并发进行推理很困难。

### 让进程休眠

sleep函数将进程挂起一段特定的时间。

pause函数让调用函数休眠，直到该进程收到一个信号。

### 加载并运行程序

execve函数在当前进程的上下文中加载并运行一个新程序。--加载可执行目标文件filename，且带参数列表argv和环境变量envp。只有当出现错误时，execve函数才会返回调用程序。所以,execve函数只调用一次且不返回。

调用execve函数之后，加载器将可执行文件中的代码和数据从磁盘复制到内存中，然后跳转到程序的第一条指令或者入口点来执行该程序。

main函数有3个参数.1)argc 给出argv[]数组中非空指针的数量.2)argv，指向argv[]数组中的第一个条目.3)envp，指向envp数组的首地址

程序和进程:程序是一堆代码和数据；程序可以作为目标文件运行在磁盘上;也可以作为段存在地址空间中。进程是执行中程序的一个实例；程序总是运行在一个进程的上下文中。

fork和execve:fork函数在新的进程中运行相同的程序，新的子进程总是父进程的一个复制品。execve函数在当前进程的上下文中加载并运行一个新的程序，它会覆盖当前进程的地址空间，但并没有创建一个新的进程。新的程序仍然有相同的PID，并且继承了调用execve函数时已经打开的所有文件描述符。


## 信号

一个信号就是一个小消息，通知进程系统中发生了某一类型的事件。

当进程运行在前台，按下ctrl+c，内核就会发送一个SIGINT信号到前台进程组的每个进程。

一个进程可以通过向另一个进程发送一个SIGKILL信号强制终止它。

当一个子进程终止或者停止时，内核会发送一个SIGCHLD信号给父进程。

### 发送信号

发送信号：内核通过更新目前进程上下文中的某个状态，发送一个信号给目的进程。发送信号有两种原因:1)内核检测到系统事件--子进程终止;2)一个进程调用了kill函数，显示的要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。

发送信号的机制是基于进程组的

进程组:每个进程都只属于一个进程组--进程组ID表示--getpgrp

默认一个子进程和它的父进程同属一个进程组--setpgid改变自己或者其它进程的进程组。--将pid的进程组改为pgid。如果pid是0，那么使用当前进成PID。如果pgid为0，那么使用pid指定的进程的PID作为进程组PID。 比如setpid(0,0)--创建一个新的进程组，进程组ID为15213，并且把进程15213加入到新的进程中。

linux> /bin.kill -9 15213 发送一个SIGKILL信号给进程组15213  如果进程为负，那么将信号发送给所有进程

从键盘发送信号:Unix shell使用作业job这个首相概念表示对一条命令行求值而创建的进程。--在任何时刻，至多只有一个或者多个前台作业和0个或者多个后台作业。

进程组ID通常取自作业父进程中的一个。

当进程运行在前台，按下ctrl+c，内核就会发送一个SIGINT信号到前台进程组的每个进程。--终止前台作业

当进程运行在前台，按下ctrl+z，内核就会发送一个SIGSTP信号到前台进程组的每个进程。--结束(挂起)前台作业

进程通过调用kill函数发送信号给其它进程(包括他们自己)

### 接收信号  

当内核把进程p从内核模式切换到用户模式时，它会检查进程p的未被阻塞的待处理信号的集合，如果这个集合为空，那么呢黑将控制转移到p的逻辑控制流的下一条指令。如果集合非空，那么内核选择集合中的某个信号k(通常是最小的k)，并强制p接收信号k。收到这个信号会触发信号采取某种行为。--完成欣慰控制传递会p的逻辑控制流的下一条指令。

每个信号都有预定义的默认行为:进程终止，进程终止并转储内存，进程停止(挂起)直到被SIGCONT信号重启，进程忽略该信号。

进程可以通过使用signal函数修改和信号想关联的默认行为--SIGSTOP和SIGKILL是不可以修改的

signal函数可以通过(1)如果handler是SIG_IGN,那么忽略类型为signum的信号(2)SIG_DFL,那么类型位signum的信号恢复为默认行为(3)handler位用户定义的函数的地址--信号处理程序

调用信号处理程序成为捕获信号，执行信号处理程序称为处理信号。

signal(int signum.sighandler_t handler)--signum为改变默认行为的信号类型

当处理程序return时，控制传递回控制流中进程被信号接收中断位置处的指令--发生信号响应中断--调用handler

信号处理程序可以被其它处理程序中断

### 阻塞和解除阻塞信号

隐式阻塞机制:内核默认阻塞任何当前处理程序正在处理信号类型的而待处理信号--程序捕获信号s，当前正在运行处理程序S发送另一个同类型信号s，直到处理程序返回，s会变成待处理而没有被接收。

显式阻塞机制:应用程序使用sigpromask函数和它的辅助函数，阻塞和解除阻塞的信号--改变当前阻塞的信号集合--blocked位向量--改变how

sigpromask(int how,const sigset_t *set,sigset_t *oldset)

how:
SIG_BLOCK:把set中的信号添加到blocked中 blocked=blocked | set
SIG_UNBLOCK:把blocked中删除set中的信号 blocked=blocked&set
SETMASK:block=set
如果oldset非空，那么blocked位向量之前的值保存在oldset中

### 编写信号处理程序  



棘手之处(1)处理程序和主程序并发执行，共享同样的全局变量--可能互相干扰(2)如何，何时接收信号有违直觉(3)不同系统有不同的信号处理语义。

Tips
(1)处理程序要尽可能简单
(2)处理程序只调用异步信号安全的函数printf,malloc,exit都不是保证安全的系统函数
(3)保存和回复errno--只有处理程序返回时才有必要，成立程序调用_exit终止该进程则没有必要
(4)阻塞所有的信号，保护对共享全局数据结构的访问
(5)volatile变量声明全局变量--告诉编译器不要缓存这个变量，从内存读取这个值--缓存中的值被一个处理程序修改，由于二者有不同的虚拟内存控制机，如果主函数读取缓存的副本，看起来这个变量的值是不变的
(6)sig_atomic_t声明标志--保证对它的读和写是原子的

信号一个和直觉不符的原因是未处理的信号是不排队的，因为pending位向量中每种类型的信号对应只有一位--每种类型最多只能有一个未处理的信号--如果存在一个未处理的信号就表明至少有一个信号到达了。

Shell和Web服务器基本结构是父进程创建一些子进程，这些子进程各自独立运行一段时间，然后终止，父进程必须回收子进程以避免在系统中留下僵尸进程。

SIGCHLD处理程序回收子进程--当子进程终止或者停止，内核发送SIGCHLD信号给父进程

注意:不可以用信号来对其它进程中发生的事件进行计数--不排队的，多了直接被丢弃

**同步流以避免并发错误**

如何编写读写相同存储位置的并发程序流程序的问题。

基本的问题是通过以某种方式同步并发流，从而得到最大的可行的交错的集合，每个可行的交错都能得到正确的结果。

注意:信号处理程序是在父进程中运行的

竞争--addjob和deletejob之间存在竞争

将主程序挂起可以节省处理器资源(让并发的程序占用处理器)--一直等待子进程终止，浪费系统资源

函数说明：pause()会令目前的进程暂停(进入睡眠状态), 直到被信号(signal)所中断.--while之后pause之前收到SIGCHLD信号，pause会永远睡眠--因为等不到信号中断了。

sleep()功能： 执行挂起一段时间，也就是等待一段时间在继续执行

sleep和pause的区别是sleep是睡眠固定时间，而pause是等待信号中断，那么等待的时间正好是子进程终止的时间

sigsuspend--每次调用sigsuspend之前，都要阻塞SIGCHLD，sigsuspend会暂时取消阻塞，然后休眠，直到父进程捕获信号，在返回之前，它会回复阻塞集合，又再次阻塞SIGCHLD

